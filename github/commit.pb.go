// Code generated by protoc-gen-gogo.
// source: commit.proto
// DO NOT EDIT!

package github

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CommitDetailTree struct {
	Sha string `protobuf:"bytes,1,opt,name=sha,proto3" json:"sha,omitempty"`
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *CommitDetailTree) Reset()                    { *m = CommitDetailTree{} }
func (m *CommitDetailTree) String() string            { return proto.CompactTextString(m) }
func (*CommitDetailTree) ProtoMessage()               {}
func (*CommitDetailTree) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{0} }

type CommitLinguist struct {
	ContentType            string `protobuf:"bytes,1,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	Disposition            string `protobuf:"bytes,2,opt,name=disposition,proto3" json:"disposition,omitempty"`
	Extname                string `protobuf:"bytes,3,opt,name=extname,proto3" json:"extname,omitempty"`
	IsBinary               bool   `protobuf:"varint,4,opt,name=is_binary,json=isBinary,proto3" json:"is_binary,omitempty"`
	IsDocumentation        bool   `protobuf:"varint,5,opt,name=is_documentation,json=isDocumentation,proto3" json:"is_documentation,omitempty"`
	IsGenerated            bool   `protobuf:"varint,6,opt,name=is_generated,json=isGenerated,proto3" json:"is_generated,omitempty"`
	IsHighRatioOfLongLines bool   `protobuf:"varint,7,opt,name=is_high_ratio_of_long_lines,json=isHighRatioOfLongLines,proto3" json:"is_high_ratio_of_long_lines,omitempty"`
	IsImage                bool   `protobuf:"varint,8,opt,name=is_image,json=isImage,proto3" json:"is_image,omitempty"`
	IsLarge                bool   `protobuf:"varint,9,opt,name=is_large,json=isLarge,proto3" json:"is_large,omitempty"`
	IsSafeToColorize       bool   `protobuf:"varint,10,opt,name=is_safe_to_colorize,json=isSafeToColorize,proto3" json:"is_safe_to_colorize,omitempty"`
	IsText                 bool   `protobuf:"varint,11,opt,name=is_text,json=isText,proto3" json:"is_text,omitempty"`
	IsVendored             bool   `protobuf:"varint,12,opt,name=is_vendored,json=isVendored,proto3" json:"is_vendored,omitempty"`
	IsViewable             bool   `protobuf:"varint,13,opt,name=is_viewable,json=isViewable,proto3" json:"is_viewable,omitempty"`
	Loc                    int32  `protobuf:"varint,14,opt,name=loc,proto3" json:"loc,omitempty"`
	Sloc                   int32  `protobuf:"varint,15,opt,name=sloc,proto3" json:"sloc,omitempty"`
	Comments               int32  `protobuf:"varint,16,opt,name=comments,proto3" json:"comments,omitempty"`
	Blanks                 int32  `protobuf:"varint,17,opt,name=blanks,proto3" json:"blanks,omitempty"`
	Type                   string `protobuf:"bytes,18,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *CommitLinguist) Reset()                    { *m = CommitLinguist{} }
func (m *CommitLinguist) String() string            { return proto.CompactTextString(m) }
func (*CommitLinguist) ProtoMessage()               {}
func (*CommitLinguist) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{1} }

type CommitFramework struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CommitFramework) Reset()                    { *m = CommitFramework{} }
func (m *CommitFramework) String() string            { return proto.CompactTextString(m) }
func (*CommitFramework) ProtoMessage()               {}
func (*CommitFramework) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{2} }

type CommitLicense struct {
	Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Url         string `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	OsiApproved bool   `protobuf:"varint,4,opt,name=osiApproved,proto3" json:"osiApproved,omitempty"`
	License     string `protobuf:"bytes,5,opt,name=license,proto3" json:"license,omitempty"`
}

func (m *CommitLicense) Reset()                    { *m = CommitLicense{} }
func (m *CommitLicense) String() string            { return proto.CompactTextString(m) }
func (*CommitLicense) ProtoMessage()               {}
func (*CommitLicense) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{3} }

type CommitFileDetail struct {
	Id         string                    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Commit     string                    `protobuf:"bytes,2,opt,name=commit,proto3" json:"commit,omitempty"`
	Author     *User                     `protobuf:"bytes,3,opt,name=author" json:"author,omitempty"`
	Committer  *User                     `protobuf:"bytes,4,opt,name=committer" json:"committer,omitempty"`
	Binary     bool                      `protobuf:"varint,5,opt,name=binary,proto3" json:"binary,omitempty"`
	Body       string                    `protobuf:"bytes,6,opt,name=body,proto3" json:"body,omitempty"`
	Patch      string                    `protobuf:"bytes,7,opt,name=patch,proto3" json:"patch,omitempty"`
	Filename   string                    `protobuf:"bytes,8,opt,name=filename,proto3" json:"filename,omitempty"`
	Language   string                    `protobuf:"bytes,9,opt,name=language,proto3" json:"language,omitempty"`
	Mimetype   string                    `protobuf:"bytes,10,opt,name=mimetype,proto3" json:"mimetype,omitempty"`
	Status     string                    `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	FileSize   int32                     `protobuf:"varint,12,opt,name=size,proto3" json:"size,omitempty"`
	Additions  int32                     `protobuf:"varint,13,opt,name=additions,proto3" json:"additions,omitempty"`
	Deletions  int32                     `protobuf:"varint,14,opt,name=deletions,proto3" json:"deletions,omitempty"`
	Licenses   map[string]*CommitLicense `protobuf:"bytes,15,rep,name=licenses" json:"licenses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Frameworks []*CommitFramework        `protobuf:"bytes,16,rep,name=frameworks" json:"frameworks,omitempty"`
	Linguist   *CommitLinguist           `protobuf:"bytes,17,opt,name=linguist" json:"linguist,omitempty"`
}

func (m *CommitFileDetail) Reset()                    { *m = CommitFileDetail{} }
func (m *CommitFileDetail) String() string            { return proto.CompactTextString(m) }
func (*CommitFileDetail) ProtoMessage()               {}
func (*CommitFileDetail) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{4} }

type CommitDetail struct {
	Author       *CommitUser       `protobuf:"bytes,1,opt,name=author" json:"author,omitempty"`
	Committer    *CommitUser       `protobuf:"bytes,2,opt,name=committer" json:"committer,omitempty"`
	CommentCount int32             `protobuf:"varint,3,opt,name=comment_count,json=commentCount,proto3" json:"comment_count,omitempty"`
	Message      string            `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	Tree         *CommitDetailTree `protobuf:"bytes,5,opt,name=tree" json:"tree,omitempty"`
	Url          string            `protobuf:"bytes,6,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *CommitDetail) Reset()                    { *m = CommitDetail{} }
func (m *CommitDetail) String() string            { return proto.CompactTextString(m) }
func (*CommitDetail) ProtoMessage()               {}
func (*CommitDetail) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{5} }

type Commit struct {
	Id        string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sha       string              `protobuf:"bytes,2,opt,name=sha,proto3" json:"sha,omitempty"`
	Author    *User               `protobuf:"bytes,3,opt,name=author" json:"author,omitempty"`
	Committer *User               `protobuf:"bytes,4,opt,name=committer" json:"committer,omitempty"`
	Commit    *CommitDetail       `protobuf:"bytes,5,opt,name=commit" json:"commit,omitempty"`
	Files     []*CommitFileDetail `protobuf:"bytes,6,rep,name=files" json:"files,omitempty"`
	Parents   []*CommitDetailTree `protobuf:"bytes,7,rep,name=parents" json:"parents,omitempty"`
	Repo      *Repository         `protobuf:"bytes,8,opt,name=repo" json:"repo,omitempty"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorCommit, []int{6} }

func init() {
	proto.RegisterType((*CommitDetailTree)(nil), "github.CommitDetailTree")
	proto.RegisterType((*CommitLinguist)(nil), "github.CommitLinguist")
	proto.RegisterType((*CommitFramework)(nil), "github.CommitFramework")
	proto.RegisterType((*CommitLicense)(nil), "github.CommitLicense")
	proto.RegisterType((*CommitFileDetail)(nil), "github.CommitFileDetail")
	proto.RegisterType((*CommitDetail)(nil), "github.CommitDetail")
	proto.RegisterType((*Commit)(nil), "github.Commit")
}
func (m *CommitDetailTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitDetailTree) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sha) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Sha)))
		i += copy(dAtA[i:], m.Sha)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *CommitLinguist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitLinguist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContentType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.Disposition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Disposition)))
		i += copy(dAtA[i:], m.Disposition)
	}
	if len(m.Extname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Extname)))
		i += copy(dAtA[i:], m.Extname)
	}
	if m.IsBinary {
		dAtA[i] = 0x20
		i++
		if m.IsBinary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDocumentation {
		dAtA[i] = 0x28
		i++
		if m.IsDocumentation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsGenerated {
		dAtA[i] = 0x30
		i++
		if m.IsGenerated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsHighRatioOfLongLines {
		dAtA[i] = 0x38
		i++
		if m.IsHighRatioOfLongLines {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsImage {
		dAtA[i] = 0x40
		i++
		if m.IsImage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLarge {
		dAtA[i] = 0x48
		i++
		if m.IsLarge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsSafeToColorize {
		dAtA[i] = 0x50
		i++
		if m.IsSafeToColorize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsText {
		dAtA[i] = 0x58
		i++
		if m.IsText {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsVendored {
		dAtA[i] = 0x60
		i++
		if m.IsVendored {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsViewable {
		dAtA[i] = 0x68
		i++
		if m.IsViewable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Loc != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Loc))
	}
	if m.Sloc != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Sloc))
	}
	if m.Comments != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Comments))
	}
	if m.Blanks != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Blanks))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *CommitFramework) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitFramework) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CommitLicense) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitLicense) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.OsiApproved {
		dAtA[i] = 0x20
		i++
		if m.OsiApproved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.License) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.License)))
		i += copy(dAtA[i:], m.License)
	}
	return i, nil
}

func (m *CommitFileDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitFileDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if m.Author != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Author.Size()))
		n1, err := m.Author.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Committer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Committer.Size()))
		n2, err := m.Committer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Binary {
		dAtA[i] = 0x28
		i++
		if m.Binary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Patch) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Patch)))
		i += copy(dAtA[i:], m.Patch)
	}
	if len(m.Filename) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Filename)))
		i += copy(dAtA[i:], m.Filename)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Mimetype) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Mimetype)))
		i += copy(dAtA[i:], m.Mimetype)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.FileSize))
	}
	if m.Additions != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Additions))
	}
	if m.Deletions != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Deletions))
	}
	if len(m.Licenses) > 0 {
		for k, _ := range m.Licenses {
			dAtA[i] = 0x7a
			i++
			v := m.Licenses[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommit(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCommit(uint64(len(k))) + msgSize
			i = encodeVarintCommit(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommit(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommit(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.Frameworks) > 0 {
		for _, msg := range m.Frameworks {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintCommit(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Linguist != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Linguist.Size()))
		n4, err := m.Linguist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *CommitDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Author != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Author.Size()))
		n5, err := m.Author.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Committer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Committer.Size()))
		n6, err := m.Committer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CommentCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.CommentCount))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Tree != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Tree.Size()))
		n7, err := m.Tree.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Sha) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommit(dAtA, i, uint64(len(m.Sha)))
		i += copy(dAtA[i:], m.Sha)
	}
	if m.Author != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Author.Size()))
		n8, err := m.Author.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Committer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Committer.Size()))
		n9, err := m.Committer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Commit != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Commit.Size()))
		n10, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCommit(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Parents) > 0 {
		for _, msg := range m.Parents {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCommit(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Repo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommit(dAtA, i, uint64(m.Repo.Size()))
		n11, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeFixed64Commit(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Commit(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCommit(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CommitDetailTree) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sha)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	return n
}

func (m *CommitLinguist) Size() (n int) {
	var l int
	_ = l
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Disposition)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Extname)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.IsBinary {
		n += 2
	}
	if m.IsDocumentation {
		n += 2
	}
	if m.IsGenerated {
		n += 2
	}
	if m.IsHighRatioOfLongLines {
		n += 2
	}
	if m.IsImage {
		n += 2
	}
	if m.IsLarge {
		n += 2
	}
	if m.IsSafeToColorize {
		n += 2
	}
	if m.IsText {
		n += 2
	}
	if m.IsVendored {
		n += 2
	}
	if m.IsViewable {
		n += 2
	}
	if m.Loc != 0 {
		n += 1 + sovCommit(uint64(m.Loc))
	}
	if m.Sloc != 0 {
		n += 1 + sovCommit(uint64(m.Sloc))
	}
	if m.Comments != 0 {
		n += 2 + sovCommit(uint64(m.Comments))
	}
	if m.Blanks != 0 {
		n += 2 + sovCommit(uint64(m.Blanks))
	}
	l = len(m.Type)
	if l > 0 {
		n += 2 + l + sovCommit(uint64(l))
	}
	return n
}

func (m *CommitFramework) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	return n
}

func (m *CommitLicense) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.OsiApproved {
		n += 2
	}
	l = len(m.License)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	return n
}

func (m *CommitFileDetail) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Author != nil {
		l = m.Author.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Committer != nil {
		l = m.Committer.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Binary {
		n += 2
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Patch)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Mimetype)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovCommit(uint64(m.FileSize))
	}
	if m.Additions != 0 {
		n += 1 + sovCommit(uint64(m.Additions))
	}
	if m.Deletions != 0 {
		n += 1 + sovCommit(uint64(m.Deletions))
	}
	if len(m.Licenses) > 0 {
		for k, v := range m.Licenses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommit(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCommit(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommit(uint64(mapEntrySize))
		}
	}
	if len(m.Frameworks) > 0 {
		for _, e := range m.Frameworks {
			l = e.Size()
			n += 2 + l + sovCommit(uint64(l))
		}
	}
	if m.Linguist != nil {
		l = m.Linguist.Size()
		n += 2 + l + sovCommit(uint64(l))
	}
	return n
}

func (m *CommitDetail) Size() (n int) {
	var l int
	_ = l
	if m.Author != nil {
		l = m.Author.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Committer != nil {
		l = m.Committer.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.CommentCount != 0 {
		n += 1 + sovCommit(uint64(m.CommentCount))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Tree != nil {
		l = m.Tree.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	l = len(m.Sha)
	if l > 0 {
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Author != nil {
		l = m.Author.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Committer != nil {
		l = m.Committer.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovCommit(uint64(l))
		}
	}
	if len(m.Parents) > 0 {
		for _, e := range m.Parents {
			l = e.Size()
			n += 1 + l + sovCommit(uint64(l))
		}
	}
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovCommit(uint64(l))
	}
	return n
}

func sovCommit(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommit(x uint64) (n int) {
	return sovCommit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CommitDetailTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitDetailTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitDetailTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitLinguist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitLinguist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitLinguist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disposition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disposition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBinary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBinary = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDocumentation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDocumentation = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGenerated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsGenerated = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHighRatioOfLongLines", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHighRatioOfLongLines = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsImage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsImage = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLarge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLarge = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSafeToColorize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSafeToColorize = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsText = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVendored", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVendored = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsViewable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsViewable = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sloc", wireType)
			}
			m.Sloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sloc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			m.Comments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Comments |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blanks", wireType)
			}
			m.Blanks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Blanks |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitFramework) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitFramework: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitFramework: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitLicense) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitLicense: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitLicense: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsiApproved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OsiApproved = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitFileDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitFileDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitFileDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Author == nil {
				m.Author = &User{}
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committer == nil {
				m.Committer = &User{}
			}
			if err := m.Committer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Binary = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimetype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimetype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Additions", wireType)
			}
			m.Additions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Additions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deletions", wireType)
			}
			m.Deletions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deletions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Licenses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCommit
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Licenses == nil {
				m.Licenses = make(map[string]*CommitLicense)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthCommit
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthCommit
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &CommitLicense{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Licenses[mapkey] = mapvalue
			} else {
				var mapvalue *CommitLicense
				m.Licenses[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frameworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frameworks = append(m.Frameworks, &CommitFramework{})
			if err := m.Frameworks[len(m.Frameworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linguist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Linguist == nil {
				m.Linguist = &CommitLinguist{}
			}
			if err := m.Linguist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Author == nil {
				m.Author = &CommitUser{}
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committer == nil {
				m.Committer = &CommitUser{}
			}
			if err := m.Committer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentCount", wireType)
			}
			m.CommentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommentCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tree == nil {
				m.Tree = &CommitDetailTree{}
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Author == nil {
				m.Author = &User{}
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committer == nil {
				m.Committer = &User{}
			}
			if err := m.Committer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &CommitDetail{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &CommitFileDetail{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, &CommitDetailTree{})
			if err := m.Parents[len(m.Parents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommit
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repository{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommit
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommit
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommit(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommit = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommit   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("commit.proto", fileDescriptorCommit) }

var fileDescriptorCommit = []byte{
	// 1012 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x8e, 0x1b, 0xc5,
	0x13, 0x8e, 0xff, 0xdb, 0x65, 0xef, 0xae, 0xd3, 0xbf, 0xfd, 0x6d, 0x86, 0x0d, 0xda, 0x04, 0x03,
	0x11, 0x7f, 0x12, 0x07, 0x19, 0x09, 0x10, 0x9c, 0xd8, 0x0d, 0x01, 0xa4, 0x95, 0x90, 0x26, 0x0b,
	0xd7, 0xd1, 0xd8, 0x6e, 0xdb, 0xad, 0x1d, 0x4f, 0x5b, 0xd3, 0x3d, 0x1b, 0xcc, 0x8d, 0xb7, 0xe0,
	0xc2, 0x6b, 0xf0, 0x06, 0x48, 0x39, 0xf2, 0x04, 0x08, 0xc2, 0x91, 0x97, 0xa0, 0xaa, 0xba, 0x67,
	0x6c, 0xef, 0x86, 0x1b, 0x87, 0xd5, 0x56, 0xd5, 0xf7, 0x55, 0x4f, 0x57, 0xf5, 0x57, 0xdd, 0x86,
	0xde, 0x44, 0x2f, 0x97, 0xca, 0x0e, 0x57, 0x99, 0xb6, 0x5a, 0x34, 0xe7, 0xca, 0x2e, 0xf2, 0xf1,
	0xf1, 0x23, 0xf7, 0x7f, 0x88, 0xe0, 0xe3, 0xb9, 0x9e, 0xeb, 0xc7, 0x0c, 0x8f, 0xf3, 0x19, 0x7b,
	0xec, 0xb0, 0xe5, 0xd2, 0x8e, 0x21, 0x37, 0x32, 0xf3, 0x76, 0x3f, 0x93, 0x2b, 0x6d, 0x94, 0xd5,
	0xd9, 0xda, 0x47, 0x6e, 0xbb, 0x4f, 0x44, 0x1b, 0xd2, 0xe0, 0x23, 0xe8, 0x9f, 0x71, 0xf0, 0x89,
	0xb4, 0xb1, 0x4a, 0x2e, 0x32, 0x29, 0x45, 0x1f, 0x6a, 0x66, 0x11, 0x07, 0x95, 0xfb, 0x95, 0x77,
	0x3a, 0x21, 0x99, 0x14, 0xc9, 0xb3, 0x24, 0xa8, 0xba, 0x08, 0x9a, 0x83, 0x5f, 0xeb, 0xb0, 0xef,
	0x12, 0xcf, 0x55, 0x3a, 0xcf, 0x95, 0xb1, 0xe2, 0x0d, 0x2a, 0x21, 0xb5, 0x32, 0xb5, 0x91, 0x5d,
	0xaf, 0xa4, 0xcf, 0xef, 0xfa, 0xd8, 0x05, 0x86, 0xc4, 0x7d, 0xe8, 0x4e, 0x95, 0xe1, 0x5d, 0x29,
	0x9d, 0xfa, 0xf5, 0xb6, 0x43, 0x22, 0x80, 0x96, 0xfc, 0xde, 0xa6, 0xf1, 0x52, 0x06, 0x35, 0x46,
	0x0b, 0x57, 0xdc, 0x85, 0x8e, 0x32, 0xd1, 0x58, 0xa5, 0x71, 0xb6, 0x0e, 0xea, 0x88, 0xb5, 0xc3,
	0xb6, 0x32, 0xa7, 0xec, 0x8b, 0x77, 0xa1, 0x8f, 0xe0, 0x54, 0x4f, 0xf2, 0x25, 0x7e, 0x2b, 0xe6,
	0xd5, 0x1b, 0xcc, 0x39, 0x50, 0xe6, 0xc9, 0x76, 0x98, 0xb6, 0x89, 0xd4, 0xb9, 0x4c, 0x65, 0x16,
	0x5b, 0x39, 0x0d, 0x9a, 0x4c, 0xeb, 0x2a, 0xf3, 0x65, 0x11, 0x12, 0x9f, 0xc1, 0x5d, 0xa4, 0x2c,
	0xd4, 0x7c, 0x11, 0x65, 0x94, 0x14, 0xe9, 0x59, 0x94, 0xe8, 0x74, 0x1e, 0x25, 0x2a, 0x95, 0x26,
	0x68, 0x71, 0xc6, 0x91, 0x32, 0x5f, 0x21, 0x23, 0x24, 0xc2, 0x37, 0xb3, 0x73, 0x84, 0xcf, 0x09,
	0x15, 0xaf, 0x01, 0x6e, 0x2b, 0x52, 0xcb, 0x78, 0x2e, 0x83, 0x36, 0x33, 0x5b, 0xca, 0x7c, 0x4d,
	0xae, 0x87, 0x92, 0x38, 0x43, 0xa8, 0x53, 0x40, 0xe7, 0xe4, 0x8a, 0x47, 0xf0, 0x3f, 0x84, 0x4c,
	0x3c, 0x93, 0x91, 0xd5, 0xd1, 0x44, 0x27, 0x3a, 0x53, 0x3f, 0xc8, 0x00, 0x98, 0x85, 0xb5, 0x3d,
	0x43, 0xe4, 0x42, 0x9f, 0xf9, 0xb8, 0xb8, 0x03, 0x98, 0x19, 0x59, 0xec, 0x4d, 0xd0, 0x65, 0x4a,
	0x53, 0x99, 0x0b, 0xf4, 0xc4, 0x3d, 0xc0, 0x4a, 0xa2, 0x2b, 0x99, 0x4e, 0x75, 0x86, 0xc5, 0xf5,
	0x18, 0x04, 0x65, 0xbe, 0xf3, 0x91, 0x82, 0xa0, 0xe4, 0xf3, 0x78, 0x9c, 0xc8, 0x60, 0xaf, 0x24,
	0xf8, 0x08, 0x9d, 0x75, 0xa2, 0x27, 0xc1, 0x3e, 0x02, 0x8d, 0x90, 0x4c, 0x21, 0xa0, 0x6e, 0x28,
	0x74, 0xc0, 0x21, 0xb6, 0xc5, 0x31, 0xb4, 0x49, 0x4c, 0xd8, 0x55, 0x13, 0xf4, 0x39, 0x5e, 0xfa,
	0xe2, 0x08, 0x9a, 0xe3, 0x24, 0x4e, 0x2f, 0x4d, 0x70, 0x9b, 0x11, 0xef, 0xd1, 0x3a, 0x2c, 0x0c,
	0xc1, 0x07, 0xcb, 0xf6, 0xe0, 0x6d, 0x38, 0x70, 0x32, 0x7a, 0x9a, 0xe1, 0x21, 0x3f, 0xd7, 0xd9,
	0x25, 0xd1, 0xf8, 0xfc, 0x9d, 0x7e, 0xd8, 0x1e, 0xfc, 0x58, 0x81, 0xbd, 0x42, 0x6e, 0x13, 0x99,
	0x1a, 0x29, 0xf6, 0xa1, 0xaa, 0xa6, 0x9e, 0x83, 0x56, 0x99, 0x55, 0xdd, 0x64, 0x15, 0xb2, 0xad,
	0x95, 0xb2, 0x25, 0x01, 0xa2, 0xd2, 0x3e, 0x5f, 0xa1, 0xf8, 0xaf, 0xb0, 0x3d, 0x4e, 0x46, 0xdb,
	0x21, 0x12, 0x60, 0xe2, 0x3e, 0xc1, 0x02, 0x42, 0x01, 0x7a, 0x77, 0xf0, 0x73, 0xa3, 0x98, 0x95,
	0xa7, 0x2a, 0x91, 0x6e, 0x5e, 0x6e, 0x6c, 0x03, 0x6b, 0x77, 0x43, 0xe6, 0x37, 0xe2, 0x3d, 0xf1,
	0x16, 0x34, 0xe3, 0xdc, 0x2e, 0x74, 0xc6, 0xbb, 0xe9, 0x8e, 0x7a, 0x43, 0x3f, 0xd8, 0xdf, 0xe2,
	0x2c, 0x86, 0x1e, 0x13, 0xef, 0x41, 0xc7, 0xf1, 0xad, 0xcc, 0x78, 0x73, 0xd7, 0x89, 0x1b, 0x98,
	0xbb, 0xec, 0x86, 0xc1, 0x09, 0xdd, 0x7b, 0xd4, 0x88, 0xb1, 0x9e, 0xae, 0x59, 0xd7, 0xd8, 0x08,
	0xb2, 0xc5, 0x21, 0x34, 0x56, 0xb1, 0x9d, 0x2c, 0x58, 0xba, 0x9d, 0xd0, 0x39, 0x74, 0x86, 0x33,
	0xac, 0x84, 0xdb, 0xd6, 0x66, 0xa0, 0xf4, 0x09, 0xc3, 0x43, 0x9b, 0xe7, 0xb1, 0x97, 0x2a, 0x62,
	0x85, 0x4f, 0xd8, 0x52, 0x2d, 0x25, 0x9f, 0x25, 0x38, 0xac, 0xf0, 0x69, 0x57, 0x06, 0x07, 0x2d,
	0x37, 0xac, 0x4b, 0xac, 0xdf, 0x79, 0xd8, 0xf8, 0xba, 0x21, 0x41, 0x93, 0x20, 0x1b, 0xa7, 0xbd,
	0x97, 0xbf, 0xdf, 0x6b, 0x53, 0x17, 0x9f, 0x61, 0x2c, 0x64, 0x44, 0xbc, 0x0e, 0x9d, 0x78, 0x3a,
	0xe5, 0x5b, 0xc0, 0xb0, 0x2c, 0x1b, 0xe1, 0x26, 0x40, 0xe8, 0x54, 0x26, 0xd2, 0xa1, 0x4e, 0x9b,
	0x9b, 0x80, 0x38, 0xc5, 0xdd, 0xba, 0x53, 0x32, 0xa8, 0xd2, 0x1a, 0xb6, 0xed, 0x41, 0xd1, 0xb6,
	0xeb, 0x27, 0x36, 0xf4, 0x02, 0x32, 0x5f, 0xa4, 0x36, 0x5b, 0x87, 0x65, 0x9e, 0xf8, 0x18, 0x60,
	0x56, 0x68, 0x90, 0x34, 0x4d, 0xab, 0xdc, 0xb9, 0xb6, 0x4a, 0x81, 0x87, 0x5b, 0x54, 0x31, 0xa2,
	0x8f, 0xbb, 0x3b, 0x90, 0x05, 0xdf, 0x1d, 0x1d, 0xed, 0xa6, 0x15, 0x37, 0x64, 0x58, 0xf2, 0x8e,
	0x43, 0xd8, 0xdb, 0xd9, 0x07, 0x49, 0xf5, 0x52, 0xae, 0x8b, 0x3b, 0x17, 0x4d, 0xf1, 0x3e, 0x34,
	0xae, 0xe2, 0x24, 0x77, 0x8a, 0xee, 0x8e, 0xfe, 0x7f, 0x7d, 0x4d, 0xce, 0x0e, 0x1d, 0xe7, 0xd3,
	0xea, 0x27, 0x95, 0xc1, 0xdf, 0x15, 0xe8, 0x6d, 0xdf, 0xe5, 0xa8, 0xa6, 0x42, 0x73, 0x15, 0x5e,
	0x42, 0xec, 0x2e, 0xb1, 0xa3, 0xbc, 0x0f, 0xb6, 0x95, 0x57, 0xfd, 0x57, 0xfa, 0x96, 0xfe, 0xde,
	0x84, 0x3d, 0x3f, 0xf1, 0x78, 0x5d, 0xe5, 0xa9, 0x65, 0x61, 0x37, 0xc2, 0x9e, 0x0f, 0x9e, 0x51,
	0x8c, 0xa6, 0x69, 0x29, 0x8d, 0x21, 0x15, 0xd5, 0xdd, 0x34, 0x79, 0x57, 0x3c, 0xc4, 0xcb, 0x00,
	0x1f, 0x1b, 0x16, 0x6f, 0x77, 0x14, 0xec, 0x7e, 0x6b, 0xf3, 0x18, 0x85, 0xcc, 0x2a, 0x26, 0xb9,
	0xb9, 0x79, 0x80, 0x7e, 0xa9, 0x42, 0xd3, 0x91, 0x6f, 0xcc, 0xa0, 0x7f, 0xbf, 0xaa, 0x9b, 0xf7,
	0xeb, 0xbf, 0x9f, 0xbe, 0x87, 0xe5, 0x9c, 0xbb, 0x02, 0x0e, 0x5f, 0x55, 0x40, 0x39, 0xfd, 0x43,
	0x68, 0xd0, 0x64, 0x19, 0x2c, 0xa0, 0x76, 0xb3, 0xda, 0x8d, 0x38, 0x43, 0x47, 0x43, 0x49, 0xb5,
	0x56, 0x71, 0xc6, 0x97, 0x6b, 0xeb, 0x55, 0x19, 0x5b, 0xfd, 0x29, 0x88, 0xe2, 0x01, 0xd4, 0xe9,
	0xc1, 0xe7, 0x49, 0xde, 0x3a, 0xbc, 0xb0, 0xfc, 0x11, 0x10, 0x32, 0x7e, 0x7a, 0xf8, 0xe2, 0xcf,
	0x93, 0x5b, 0x2f, 0x5e, 0x9e, 0x54, 0x7e, 0xc3, 0xbf, 0x3f, 0xf0, 0xef, 0xa7, 0xbf, 0x4e, 0x6e,
	0x8d, 0x9b, 0xfc, 0x73, 0xe0, 0xc3, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xec, 0x47, 0x95, 0xdf,
	0x86, 0x08, 0x00, 0x00,
}
